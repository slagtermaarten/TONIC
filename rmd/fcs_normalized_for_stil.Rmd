---
title: "Gene expression FCs normalized for stromal TIL"
author: "Maarten Slagter"
output:
  html_document:
    toc: true
    number_sections: true
    theme: united
---


```{r, warning=FALSE, echo=FALSE, cache = F}
setwd('~/TONIC')
options(mc.cores = 2)
knitr::opts_chunk$set(message = FALSE, cache = T, cache.lazy = F,
                      cache.comments = F, autodep = T, warning = FALSE,
                      results = 'hide', fig.keep = 'high',
                      echo = TRUE, error = FALSE)
knitr::opts_knit$set(progress = TRUE, verbose = TRUE)
library(tidybayes)
# devtools::install_github('paul-buerkner/brms')
library(brms)

# knitr::clean_cache()
# knitr::opts_chunk$get("cache.path")
# knitr::knit_global()
# setwd('~/Projects/TONIC')
source('R/init.R')
```

# Introduction

Due to relatively small patient numbers per treatment arm, spontaneous biases in
baseline factors could confound differences in the FCs of the genesets we've
decided to follow over time - those associated with clinical response at the on
nivolumab timepoint. Here I show that among the patients for whom NanoString
assays are available both On nivo and at Baseline, inter-arm differences in
stromal TIL% between the treatment arms are not detectable. Stromal TIL
additionally only seems weakly associated with the FCs of the median geneset
scores. As an effect of that, trying to correct for stromal TIL by explicitly
taking it along in a regression model does not alter the relative weight that is
assigned to the various treatment arms - as one would expect based on the
observed data.

# Methods

The log2 FC in the median of the 12-geneset values per patient was modelled as a
function of either the treatment arm alone (the baseline model) or both the
treatment arm and the baseline level of stromal TIL percentage. The latter could
be interpreted as a measure of the baseline immunological presence in the
assayed sample and hence as a proxy for the local immune system's capability of
inducing an inflamed state.

In a Bayesian framework, FCs were assumed to be Gaussian distributed with a mean
that is composed of the sum of arm and stromal TIL effects. Arm coefficients
were regularized by drawing them from a common $t$-distribution. For the prior
distribution on the stromal TIL, we also chose a $t_2$-distribution. TODO: check
and further specify exact parameters.

# No apparent relationship between baseline factors and expression FCs

```{r, warning=FALSE, echo=FALSE}
# source('R/test_associations.R')
source('R/bayes.R')
# debugonce(prepare_test_gene_set_difference)
dtf <- prep_comp_data(tp1 = 'Baseline', tp2 = 'Post-induction')
dtf <- prep_comp_data(tp1 = 'Baseline', tp2 = 'On nivo')
```

```{r, warning=FALSE, echo=FALSE}
explore_confounder('s_til')
explore_confounder('ca15_3')
```

# Regression modelling of the observed FCs

```{r, warning=FALSE, echo=FALSE}
source('R/bayes.R')

## Test stability of inferences
dtf <- prep_comp_data(tp1 = 'Baseline', tp2 = 'Post-induction')
# hlm_test <- run_sim(df_sigma_FC = 1, df_sigma_arm = 1,
#                data = dtf, adapt_delta = .99)
sr(hlm_test)

fn <- 'test.pdf'
pdf(fn)
pairs(hlm_test, las = 1)
dev.off()
sys_file_open(fn)
```

```{r, warning=FALSE, echo=FALSE}
source('R/bayes.R')

dtf <- prep_comp_data(tp1 = 'Baseline', tp2 = 'Post-induction')

extract_rel_parms <- function(df_sigma_FC = 1, df_sigma_arm = 3) {
  hlm <- run_sim(df_sigma_FC = df_sigma_FC, df_sigma_arm = df_sigma_arm,
                 data = dtf, adapt_delta = .99)
  get_posterior_mean(hlm,
                     # grep('df_sigma_FC|df_sigma_arm|FC|normalized', names(hlm), value = T)) %>%
                     grep('normalized', names(hlm), value = T)) %>%
    # debug_pipe
    { .[, 'mean-all chains'] }
}

if (T) {
  hyper_param_scan <- expand.grid(df_sigma_FC = 1:6, df_sigma_arm = 1:6) %>%
    as.data.table
  hyper_param_scan %<>%
    { .[, extract_rel_parms(df_sigma_FC = df_sigma_FC,
                            df_sigma_arm = df_sigma_arm),
        by = .(df_sigma_FC, df_sigma_arm)] }
  hyper_param_scan$param_name <-
    names(extract_rel_parms(df_sigma_FC = 1, df_sigma_arm = 1))
  hyper_param_scan <- dcast(hyper_param_scan,
                            df_sigma_FC + df_sigma_arm ~ param_name,
                            value.var = 'V1')
  saveRDS(hyper_param_scan, file.path(rds_dir, 'hyper_param_scan.rds'))
} else {
  sr(hyper_param_scan)
}

ggplot(hyper_param_scan, aes(x = as.factor(df_sigma_FC),
                             y = as.factor(df_sigma_arm),
                             fill = `sd_arm[4]`)) +
 geom_tile() +
 scale_x_discrete(expand = c(0, 0)) +
 scale_y_discrete(expand = c(0, 0)) +
 theme(legend.text = element_text(size = 5), legend.direction = 'vertical',
       legend.position = 'right')
```

## Acount for baseline levels

```{r, warning=FALSE, echo=FALSE}
# source('R/init.R')
source('R/bayes.R')
getDoParWorkers()
options(mc.cores = 32)

data_pi <- prep_comp_data(tp1 = 'Baseline', tp2 = 'Post-induction')
## Post induction model fits
pi_BM_sims <- list(
  hlm = run_sim(data = data_pi,
    use_baseline = F, use_clinical_response = F),
  hlm_b = run_sim(data = data_pi,
    use_baseline = T, use_clinical_response = F),
  hlm_r = run_sim(data = data_pi,
    use_baseline = F, use_clinical_response = T),
  hlm_b_r = run_sim(data = data_pi,
    use_baseline = T, use_clinical_response = T),
  hlm_b_r_d = run_sim(data = data_pi,
    use_baseline = T, use_clinical_response = T,
    use_TL = T, use_LN = F),
  hlm_b_r_l = run_sim(data = data_pi,
    use_baseline = T, use_clinical_response = T,
    use_TL = F, use_LN = T),
  hlm_b_r_d_l = run_sim(data = data_pi,
    use_baseline = T, use_clinical_response = T,
    use_TL = T, use_LN = T)
)
saveRDS(pi_BM_sims, file.path(rds_dir, 'pi_BM_sims.rds'))

purrr::map(pi_BM_sims, function(obj) {
  i_pars <- intersect(fitted_coefs(obj), c('bc[1]', 'rc[1]', 'tc[1]', 'lc[1]'))
  if (length(i_pars) == 0) return(NULL)
  rstan::extract(obj, pars = i_pars) %>%
    as.data.table %>%
    { .[, lapply(.SD, mean)] }
})
```

```{r, warning=FALSE, echo=FALSE}
## Try to print posterior means only
# lapply(pi_BM_sims, function)
pi_BM_sims$hlm_b_r
pi_BM_sims$hlm_b_r_l
pi_BM_sims$hlm_b_r_d_l
lapply(kj
compare(pi_BM_sims[[1]], pi_BM_sims[[2]], pi_BM_sims[[3]], pi_BM_sims[[4]])
compare(x = pi_BM_sims)
```

```{r, eval = F, warning=FALSE, echo=FALSE}
data_on <- prep_comp_data(tp1 = 'Baseline', tp2 = 'On nivo')
## On-nivo model fits
on_BM_sims <- list(
  hlm = run_sim(data = data_on,
    use_baseline = F, use_clinical_response = F),
  hlm_b = run_sim(data = data_on,
    use_baseline = T, use_clinical_response = F),
  hlm_r = run_sim(data = data_on,
    use_baseline = F, use_clinical_response = T),
  hlm_b_r = run_sim(data = data_on,
    use_baseline = T, use_clinical_response = T),
  hlm_b_r_d = run_sim(data = data_on,
    use_baseline = T, use_clinical_response = T,
    use_TL = T, use_LN = F),
  hlm_b_r_l = run_sim(data = data_on,
    use_baseline = T, use_clinical_response = T,
    use_TL = F, use_LN = T)
  hlm_b_r_d_l = run_sim(data = data_on,
    use_baseline = T, use_clinical_response = T,
    use_TL = T, use_LN = T),
)
saveRDS(on_BM_sims, file.path(rds_dir, 'on_BM_sims.rds'))
```


```{r, warning=FALSE, echo=FALSE}
source('R/init.R')
source('R/bayes.R')
# on_BM_sims <- readRDS(file.path(rds_dir, 'on_BM_sims.rds'))
pi_BM_sims <- readRDS(file.path(rds_dir, 'pi_BM_sims.rds'))
```

```{r, warning=FALSE, echo=FALSE}
source('R/bayes.R')
# imap(pi_sims, function(obj, name) {
#   plot_params(p_dat = obj,
#     mn = paste0('post_induction_', gsub('hlm_', '', name)))
# }

# plot_params(p_dat = hlm, mn = 'post_induction')
# plot_params(p_dat = hlm_b, mn = 'post_induction_b')
# plot_params(p_dat = hlm_r, mn = 'post_induction_r')
# plot_params(p_dat = hlm_b_r, mn = 'post_induction_b_r')
# plot_params(p_dat = hlm_on_b_r, mn = 'on_nivo_b_r')
invisible(plot_params(p_dat = pi_BM_sims$hlm_b_r_l,
    mn = 'post_induction_b_r_l'))
pi_BM_sims$hlm_b_r_l
```

```{r, warning=FALSE, echo=FALSE}
data_pi <- prep_comp_data(tp1 = 'Baseline', tp2 = 'Post-induction')
# data_pi <- prep_comp_data(tp1 = 'Baseline', tp2 = 'On nivo')
p <- ggplot(data_pi,
  aes(x = clinical_response, y = FC, fill = clinical_response))
p <- p + geom_boxplot(show.legend = F)
p <- p + facet_wrap(~arm, nrow = 5)
p <- p + coord_flip()
p <- p + scale_fill_manual(values = tonic_color_palettes[['clinical_response']])
p <- p + scale_x_discrete(name = 'Clinical response')
p <- p + scale_y_continuous(name = 'log2FC inflammation score')
CR_boxplot <- p
# p <- ggplot(data_pi, aes(x = clinical_response, y = FC_comp)) + geom_boxplot()
# p + facet_grid(~arm)
# data_pi[, .N, .(arm, clinical_response)][order(arm, clinical_response)]
```

```{r, warning=FALSE, echo=FALSE}
data_pi <- prep_comp_data(tp1 = 'Baseline', tp2 = 'Post-induction')
data_pi[, lymphnode_only_disease :=
  ifelse(lymphnode_only_disease, 'Lymph node only mets', 'Mets to other sites')]
data_pi[, lymphnode_only_disease := factor(lymphnode_only_disease,
  levels = c('Lymph node only mets', 'Mets to other sites'))]

LN_boxplot <- ggplot(data_pi, aes(x = lymphnode_only_disease, y = FC)) +
  geom_boxplot() +
  geom_point(data =
    data_pi[, .('FC' = mean(FC)), by = .(lymphnode_only_disease)],
    colour = 'red', size = 2) +
  scale_x_discrete(name = '') +
  scale_y_continuous(name = 'log2FC inflammation score') +
  rotate_x_labels(45)

TL_boxplot <- ggplot(data_pi,
  aes(x = lines_of_therapy_for_metastatic_disease > 0, y = FC)) +
  geom_boxplot() +
  geom_point(data =
    data_pi[, .('FC' = mean(FC)),
       by = .(lines_of_therapy_for_metastatic_disease > 0)],
    colour = 'red', size = 2) +
  scale_x_discrete(name = '# TL > 0') +
  scale_y_continuous(name = 'log2FC inflammation score') +
  rotate_x_labels(45)

CR_boxplot <- ggplot(data_pi,
  aes(x = clinical_response, y = FC)) +
  geom_boxplot() +
  geom_point(
    data = data_pi[, .('FC' = mean(FC)), by = .(clinical_response)],
    colour = 'red', size = 2) +
  scale_x_discrete(name = 'Clinical response') +
  scale_y_continuous(name = 'log2FC inflammation score') +
  rotate_x_labels(45)
```

```{r, warning=FALSE, echo=FALSE}
data_pi[, .N, by = .(arm, lines_of_therapy_for_metastatic_disease)]
data_pi[, mean(lines_of_therapy_for_metastatic_disease), by = .(arm)]
data_pi[, .('frac_LN_only' = mean(lymphnode_only_disease)), by = .(arm)]
```

```{r, warning=FALSE, echo=FALSE}
plots <-
  list(
    prep_comp_data(tp1 = 'Baseline', tp2 = 'Post-induction') %>%
      ggplot(aes(x = Baseline, y = FC)) + 
      geom_point() + geom_smooth() +
      ylab('log2FC inflammation score') +
      xlab('Baseline inflammation score') + 
      theme(text = element_text(size = 8)),
    CR_boxplot + theme(text = element_text(size = 8)),
    LN_boxplot + theme(text = element_text(size = 8)),
    TL_boxplot + theme(text = element_text(size = 8))
  )

fn <- file.path(img_dir, 'panel_bayesian_covariates.pdf')
plot_panel_layout(plots, filename = fn, ncol = 2, labels = tolower(LETTERS),
                  w = 19.5, h = 20, panel_padding = .5)
```

```{r, warning=FALSE, echo=FALSE}
# devtools::load_all('~/libs/maartenutils')
source('R/bayes.R')

# plot_params(p_dat = on_BM_sims$hlm_b_r, mn = 'post_induction_b_r')
plots <-
  list(
    NA,
    plot_params(p_dat = pi_BM_sims$hlm, mn = 'post_induction'),
    prep_comp_data(tp1 = 'Baseline', tp2 = 'Post-induction') %>%
      ggplot(aes(x = Baseline, y = FC)) + geom_point() + geom_smooth() +
      ylab('log2FC inflammation score') +
      xlab('Baseline inflammation score') + theme(text =
        element_text(size = 8)),
    plot_params(p_dat = pi_BM_sims$hlm_b, mn = 'post_induction_b'),
    CR_boxplot + theme(text = element_text(size = 8)),
    plot_params(p_dat = pi_BM_sims$hlm_b_r, mn = 'post_induction_b_r'),
    LN_boxplot + theme(text = element_text(size = 8)),
    plot_params(p_dat = pi_BM_sims$hlm_b_r_l,
        mn = 'post_induction_b_r_d_l')
  )

fn <- file.path(img_dir, 'panel_bayesian_revisions_t_dist.pdf')
plot_panel_layout(plots, filename = fn, ncol = 2, labels = tolower(LETTERS),
                  w = 19.5, h = 27.7, panel_padding = .5)
```


```{r, warning=FALSE, echo=FALSE}
devtools::load_all(file.path('~/libs', 'maartenutils'))

plots <-
list(prep_comp_data(tp1 = 'Baseline', tp2 = 'Post-induction') %>%
       ggplot(aes(x = Baseline, y = FC)) + geom_point() + geom_smooth() +
       ylab('log2 FC baseline vs. post-induction') +
       xlab('Baseline gene set score'),
     prep_comp_data(tp1 = 'Baseline', tp2 = 'On nivo') %>%
       ggplot(aes(x = Baseline, y = FC)) + geom_point() + geom_smooth() +
       ylab('log2 FC baseline vs. on nivolumab') +
       xlab('Baseline gene set score'),
     plot_params(hlm_pi, mn = 'post_induction', save_plot = F) +
       ggtitle('Post-induction vs. baseline'),
     plot_params(hlm_b_pi, mn = 'post_induction_use_baseline', save_plot = F) +
       ggtitle('Post-induction vs. baseline\n\\w baseline score'),
     plot_params(hlm, mn = 'on_nivo', save_plot = F) +
       ggtitle('On nivolumab vs. baseline'),
     plot_params(hlm_b, mn = 'on_nivo_use_baseline', save_plot = F) +
       ggtitle('On nivolumab vs. baseline\n\\w baseline score')
     )
# { align_plots(plotlist = ., 'hv') }

plot_panel_layout(plots, filename = file.path(img_dir, 'panel_bayesian.pdf'),
                  ncol = 2)
```

```{r, warning=FALSE, echo=FALSE}
names(hlm_b)

rstan::extract(hlm_b, pars = c('Y_arm[1]', 'Y_arm[4]')) %>%
  as.data.table %>%
  set_colnames(c('ref', 'test')) %>%
  { .[, .(mean(test >= ref))] }
rstan::extract(hlm_b, pars = c('Y_arm[1]', 'Y_arm[5]')) %>%
  as.data.table %>%
  set_colnames(c('ref', 'test')) %>%
  { .[, .(mean(test >= ref))] }
```


```{r, warning=FALSE, echo=FALSE}
brm_fc_s <- do.call('brm',
                  c(list(formula = bf(FC ~ 0 + (1 | arm), nl = F),
                          prior = set_prior('student_t(10, 0, 5)',
                                            class = 'sd', group = 'arm'),
                          data = dtf, family = gaussian()),
                    brms_settings[c('warmup', 'iter', 'chains', 'control')]))
stancode(brm_fcs[[3]])
standata(brm_fc_s)
```


```{r, warning=FALSE, echo=FALSE}
priors <- c("normal(0,10)"
stancode(brm_fc)
p_names <- names(brm_fc$fit@sim$samples[[1]])
```

```{r, warning=FALSE, echo=FALSE}
p <- stanplot(sigma_brm_fcs[[3]], pars = '^r_.*(arm)',
              type = 'intervals') + theme_ms()
p <- p + scale_y_discrete(limits = rev(grep('r_arm',
                                        names(brm_fc$fit@sim$samples[[1]]),
                                        value = T)),
                          labels = rev(treatment_arms))
p <- p + xlab('Credible interval for log2(FC)')
print(p)
ggsave(p, filename = file.path(img_dir, 'bayesian_fc.pdf'))
```



```{r, warning=FALSE, echo=FALSE}
posterior_samples(brm_fc, "b")
get_prior(FC ~ 0 + (0 + intercept | arm), data = dtf, family = gaussian())
get_prior(FC ~ 0 + intercept, data = dtf, family = gaussian())
```

```{r, warning=FALSE, echo=FALSE}
pp_check(brm_fc)
plot(brm_fc)
```

```{r, eval = F, brm2, warning=FALSE, echo=FALSE}
# source('R/bayes.R')
# devtools::load_all(file.path('~/libs', 'maartenutils'))
# debugonce(posterior_histogram)
brm_fc_stil <- do.call('brm',
                       c(list(formula = bf(FC ~ s_til + (1 | arm), nl = F),
                              data = dtf, family = gaussian()),
                              brms_settings[c('warmup', 'iter',
                                              'chains', 'control')]))
print(brm_fc_stil)
```

Comparing the leave-one-out-cross-validation performance, the simpler model
taking along just treatment arm actually prevails. This is not unexpected given
the weak relationship between stromal TIL and treatment arm in the assayed
samples. Stromal TIL is given a very weak estimate in the expanded model; the
models are virtually identical.

```{r, warning=FALSE, echo=FALSE}
loo(brm_fc, brm_fc_stil)
```

Assessing the posterior distributions of arm-coefficients in the models, we see
that the effects ascribed to Cisplatin are higher than that of Doxorubicin and
that this difference is slightly increased when accounting for Stromal TIL -
indeed stromal TIL levels are slightly higher in Dox arm, making the
contribution of the stromal TIL coefficient to the observed FCs slightly larger
here. Assuming validity of the data generating model and convergence of the
MCMC-sampling (highly probably given the convergence estimates and MCMC-traces),
we can estimate that the probability that Cisplatin induces higher FCs than
Doxorubicin is ~80%. I haven't done other comparisons yet, should I compare all
induction arms to the No induction arm?

```{r, warning=FALSE, echo=FALSE, fig.width = 14/2.54, fig.height = 10/2.54}
source('R/bayes.R')
# brm_fc
p_names <- names(brm_fc$fit@sim$samples[[1]])
# debugonce(posterior_histogram)

posterior_histogram(brms_object = brm_fc,
                    name = 'Model: Induction therapy',
                    binwidth = .05,
                    cols = tonic_color_palettes[['arm']],
                    x_lab = 'Contribution to FC',
                    # variables = c('Doxorubicin', 'Cisplatin', 'No.induction')) +
                    variables = gsub(' ', '\\.', treatment_arms)) +
  theme(legend.position = 'right') +
  ggtitle('Baseline model')
```

```{r, warning=FALSE, echo=FALSE}
p <- stanplot(brm_fc, pars = '^r_.*(arm)', type = 'intervals') + theme_ms()
p <- p + scale_y_discrete(limits = rev(grep('r_arm',
                                        names(brm_fc$fit@sim$samples[[1]]),
                                        value = T)),
                          labels = rev(treatment_arms))
p <- p + xlab('Arm FC relative to all patients (log2)')
print(p)
fn <- file.path(img_dir, 'bayesian_FC_intercepts.pdf')
ggsave(plot = p, file = fn,
       width = 8, height = 8, units = 'cm')
sys_file_open(fn)
```

```{r, warning=FALSE, echo=FALSE}
dtf <- extract_params(brm_fc,
               params = grep('r_arm', names(brm_fc$fit@sim$samples[[1]]),
                             value = T))
lapply(dtf, function(x) quantile(x, probs = c(0.025, .975)))
lapply(dtf, function(x) quantile(x, probs = c(0.05, .95)))
```

```{r, warning=FALSE, echo=FALSE, fig.width = 14/2.54, fig.height = 10/2.54}
posterior_histogram(brms_object = brm_fc_stil,
                    name = 'Model: Induction therapy + stromal TIL',
                    cols = tonic_color_palettes[['arm']],
                    x_lab = 'Contribution to FC',
                    variables = c('Doxorubicin', 'Cisplatin', 'No.induction')) +
  theme(legend.position = 'right') +
  ggtitle('Expanded model')
```



```{r, warning=FALSE, echo=FALSE}
compute_bayesian_p_val <- function(brms_object = brm_fc,
                                   name = '',
                                   offset_val = 1,
                                   group_name = 'induction_therapy',
                                   param_capture = '.*\\[(.*),Intercept\\]',
                                   x_lab = 'Contribution to response probability',
                                   cols = NULL,
                                   variables = c('Doxorubicin', 'Cisplatin')) {
  ## Subselect group variables
  p_names <- names(brms_object$fit@sim$samples[[1]])
  p_names <- grep(param_capture, p_names, value = T)
  p_names <- setNames(p_names,
                      tolower(gsub(param_capture, '\\1', p_names)))
  if (all(sapply(variables, is.null)))
    variables <- names(p_names)

  p_dat <- as.data.frame(extract_params(brms_object, p_names))
  comp_vals <- setdiff(1:length(p_names), offset_val)
  setNames(sapply(comp_vals, function(comp_val)
           mean(p_dat[, offset_val] < p_dat[, comp_val])),
           names(p_names)[comp_vals])
  sapply(setNames(comp_vals, names(p_names)[comp_vals]),
         function(x) quantile(p_dat[, x], probs = c(.025, .5, .975)))
}
compute_bayesian_p_val()
```
