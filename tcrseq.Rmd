---
title: "TIL TCR repertoire and relationship to induction arm and clinical response"
author: "Maarten"
output: html_document
---


```{r, warning=FALSE, echo=FALSE}
knitr::opts_chunk$set(message = FALSE, cache = T, cache.lazy = F,
                      cache.comments = F, autodep = T, warning = FALSE,
                      echo = TRUE, error = FALSE)
knitr::opts_knit$set(progress = TRUE, verbose = TRUE)
```

```{r, warning=FALSE, echo=FALSE}
source('R/init.R')
```

# Relationship between various repertoire size estimators

Various (statistical) methods of estimating the total repertoire size,
extrapolating from the observed to the unobserved total.

```{r, fig.width = 12, fig.height = 6, warning=FALSE, echo=FALSE}
plot_cor_mat()
## Separating by timepoint does not change these correlations for the Adapative
## data, as expected
plot_cor_mat(tp = 'Baseline')
plot_cor_mat(tp = 'Post-induction')
plot_cor_mat(tp = 'On nivo')
```

# Relationship between distribution and induction treatment & clinical response

```{r, warning=FALSE, echo=FALSE}
# devtools::install_github('Rdatatable/data.table')
source('R/plotting_adaptive.R')
patient_labels[, 'clonality' := 1 - pielou_evenness]
facet_var = NULL
facet_var = rev(c('arm', 'clinical_response'))
facet_var = 'clinical_response'
facet_var = 'arm'
alpha_lev = .8

var1 = 'pielou_evenness'
var1 = 'sample_clonality'
var2 = 'efron_thisted_estimator'

plot_adaptive_FC(facet_var = facet_var, var1 = var1, var2 = var2)
```

```{r, warning=FALSE, echo=FALSE}
s_plot <- ggplot(p_dat, aes(x = efron_thisted_estimator,
                            y = pielou_evenness,
                            label = timepoint_number,
                            shape = comb_time_resp,
                            group = patient,
                            colour = comb_time_resp)) +
  geom_line(alpha = alpha_lev, show.legend = F) +
  geom_point(size = 2, alpha = alpha_lev) +
  # ggrepel::geom_text_repel(segment.color = 'grey90', color = 'black') +
  # geom_text(color = 'white') +
  # geom_smooth(se = F) +
  scale_fill_manual(values = comb_time_resp_palette) +
  scale_colour_manual(name = '', values = comb_time_resp_palette) +
  scale_shape_manual(name = '',
                     values = setNames(c(1, 2, 3, 1, 2, 3) + 14,
                                       names(comb_time_resp_palette))) +
  scale_x_continuous('Repertoire size', trans = 'log10', expand = c(0, 0)) +
  scale_y_continuous('Repertoire evenness', trans = 'identity',
                     expand = c(0, 0)) +
  theme(legend.position = 'top', legend.direction = 'vertical') +
  gg_legend_alpha_cancel
  # guides(shape = guide_legend(nrow = 3))

if (!is.null(facet_var)) {
  s_plot <- s_plot + facet_wrap(as.formula(sprintf('~ %s',
                                                   paste(facet_var,
                                                         collapse = ' + '))),
                                nrow = length(facet_var))
}
print(s_plot)
```

```{r, warning=FALSE, echo=FALSE}
# source('R/init.R')
source('R/plotting_nanostring.R')
source('R/plotting_adaptive.R')
# plot_parallel_adaptive(p_var = 'efron_thisted_estimator')
# plot_parallel_adaptive(p_var = 'sample_clonality', facet_var = NULL)
plot_parallel_adaptive(p_var = 'sample_clonality', compartment = 'blood',
                       facet_var = NULL)
```

```{r, warning=FALSE, echo=FALSE}
source('R/plotting_nanostring.R')
cowplot::plot_grid(
  plot_parallel_adaptive(p_var = 'efron_thisted_estimator') + remove_x +
    remove_legend + scale_y_continuous(trans = 'log10',
                                       name = 'Repertoire size'),
  plot_parallel_adaptive(p_var = 'pielou_evenness') + remove_strip +
    theme(legend.position = 'top'),
  s_plot + remove_strip, ncol = 1, align = 'v', rel_heights = c(.4, .4, .6))
```

```{r, warning=FALSE, echo=FALSE}
compare_adaptive_summary_stats <- function(tp1 = 'Baseline',
                                           tp2 = 'On nivo',
                                           facet_var = 'arm',
                                           comp_measure = 'pielou_evenness') {

  t_dat <- patient_labels[, {
    .SD[timepoint == tp2, get(comp_measure)] -
    .SD[timepoint == tp1, get(comp_measure)]
  }, by = patient]
  setnames(t_dat, 'V1', 'value')

  t_dat <- merge(t_dat, patient_labels, all.x = T, all.y = F) %>%
    unique(by = c('patient'))

  label_proc <- function(labels)
    sapply(labels, function(lab) parse(text = lab))

  # t_dat[, label := NULL]
  t_dat[!is.na(value), 'label' := sprintf('%s~(italic(n)==%d)',
                                          clinical_response, .N),
        by = c(facet_var, 'clinical_response')]

  ggplot(t_dat[!is.na(label)],
         aes(x = label, y = value, fill = clinical_response)) +
    geom_boxplot(varwidth = F) +
    ggbeeswarm::geom_quasirandom() +
    # ggpubr::compare_means(method = 'wilcox.test') +
    scale_y_continuous(name = sprintf('%s %s vs. %s',
                                      var_to_label(comp_measure),
                                      tp2, tp1)) +
    scale_x_discrete(name = '', labels = label_proc) +
    facet_grid(as.formula(sprintf('~ %s', facet_var)), scales = 'free_x') +
    rotate_x_labels(45) +
    theme(legend.position = 'none')
}

compare_adaptive_summary_stats(tp1 = 'Baseline', tp2 = 'Post-induction',
                               comp_measure = 'pielou_evenness')
compare_adaptive_summary_stats(tp1 = 'Baseline', tp2 = 'On nivo',
                               comp_measure = 'pielou_evenness')

compare_adaptive_summary_stats(tp1 = 'Baseline', tp2 = 'Post-induction',
                               comp_measure = 'sample_cells_mass_estimate')
compare_adaptive_summary_stats(tp1 = 'Baseline', tp2 = 'On nivo',
                               comp_measure = 'sample_cells_mass_estimate')

compare_adaptive_summary_stats(tp1 = 'Baseline', tp2 = 'Post-induction',
                               comp_measure = 'productive_clonality')
compare_adaptive_summary_stats(tp1 = 'Baseline', tp2 = 'On nivo',
                               comp_measure = 'productive_clonality')
```

```{r, eval = F, warning=FALSE, echo=FALSE}
devtools::load_all(file.path('~/libs', 'maartenutils'))
arr <- w_fread(file.path(p_root, 'data-raw', 'AdaptiveAllRearrangements.tsv'),
               col_classes = c('productive_frequency' = 'numeric'))
arr[, productive_frequency := as.numeric(productive_frequency)]
arr[, uniqueN(amino_acid)]
# arr[, sum(productive_frequency, na.rm = T), by = sample_name][, table(V1)]

```

Combine two timepoints or samples (e.g. blood vs. tumor) by computing:
  * Spearman and Pearson correlation coefficients between TCR clones sizes
  * Fraction of non-axis`*` corresponding quartile TCR clones. Non-axis is
    defined as not zero in either timepoint, corresponding quartile as having 
  * 
