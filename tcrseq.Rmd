---
title: "TIL TCR repertoire and relationship to induction arm and clinical response"
author: "Maarten"
output: html_document
---


```{r, warning=FALSE, echo=FALSE}
knitr::opts_chunk$set(message = FALSE, cache = T, cache.lazy = F,
                      cache.comments = F, autodep = T, warning = FALSE,
                      results = 'hide', fig.keep = 'high',
                      echo = TRUE, error = FALSE)
knitr::opts_knit$set(progress = TRUE, verbose = TRUE)
```

```{r, warning=FALSE, echo=FALSE}
source('R/init.R')
```

# Relationship between various repertoire size estimators

Various (statistical) methods of estimating the total repertoire size,
extrapolating from the observed to the unobserved total.

```{r, fig.width = 12, fig.height = 6, warning=FALSE, echo=FALSE}
plot_cor_mat()
## Separating by timepoint does not change these correlations for the Adapative
## data, as expected
plot_cor_mat(tp = 'Baseline')
plot_cor_mat(tp = 'Post-induction')
plot_cor_mat(tp = 'On nivo')
```

# Relationship between distribution and induction treatment & clinical response

```{r, eval = F, warning=FALSE, echo=FALSE}
# devtools::install_github('Rdatatable/data.table')
source('R/plotting_adaptive.R')
facet_var = NULL
facet_var = rev(c('arm', 'clinical_response'))
facet_var = 'clinical_response'
facet_var = 'arm'
alpha_lev = .8
```

```{r, warning=FALSE, echo=FALSE}
source('R/plotting_adaptive.R')
plot_adaptive_FC(facet_var = 'arm', 
                 p_timepoints = c('Baseline', 'Post-induction', 'On nivo'),
                 var1 = 'sample_clonality', var2 = 'efron_thisted_estimator',
                 colour_var = 'comb_time_resp')
```

```{r, warning=FALSE, echo=FALSE}
source('R/plotting_adaptive.R')
plot_adaptive_FC(facet_var = 'arm', 
                 p_timepoints = c('Baseline', 'Post-induction'),
                 var1 = 'sample_clonality', var2 = 'efron_thisted_estimator',
                 colour_var = 'comb_time_resp')
```

```{r, warning=FALSE, echo=FALSE}
plot_adaptive_FC(facet_var = 'arm', 
                 p_timepoints = c('Baseline', 'On nivo'),
                 var1 = 'sample_clonality', var2 = 'efron_thisted_estimator',
                 colour_var = 'comb_time_resp')
```

```{r, eval = F, warning=FALSE, echo=FALSE}
s_plot <- ggplot(patient_labels, aes(x = efron_thisted_estimator,
                                     y = sample_clonality,
                                     label = timepoint_number,
                                     shape = comb_time_resp,
                                     group = patient,
                                     colour = comb_time_resp)) +
  geom_line(alpha = alpha_lev, show.legend = F) +
  geom_point(size = 2, alpha = alpha_lev) +
  # ggrepel::geom_text_repel(segment.color = 'grey90', color = 'black') +
  # geom_text(color = 'white') +
  # geom_smooth(se = F) +
  scale_fill_manual(values = comb_time_resp_palette) +
  scale_colour_manual(name = '', values = comb_time_resp_palette) +
  scale_shape_manual(name = '',
                     values = setNames(c(1, 2, 3, 1, 2, 3) + 14,
                                       names(comb_time_resp_palette))) +
  scale_x_continuous('Repertoire size', trans = 'log10', expand = c(0, 0)) +
  scale_y_continuous('Repertoire evenness', trans = 'identity',
                     expand = c(0, 0)) +
  theme(legend.position = 'top', legend.direction = 'vertical') +
  gg_legend_alpha_cancel
  # guides(shape = guide_legend(nrow = 3))

if (!is.null(facet_var)) {
  s_plot <- s_plot + facet_wrap(as.formula(sprintf('~ %s',
                                                   paste(facet_var,
                                                         collapse = ' + '))),
                                nrow = length(facet_var))
}
print(s_plot)
```

```{r, warning=FALSE, echo=FALSE, fig.width = 4, fig.height = 6}
source('R/plotting_nanostring.R')
source('R/plotting_adaptive.R')
plot_parallel_adaptive(p_var = 'efron_thisted_estimator', compartment = 'tumor',
                       facet_var = NULL)
plot_parallel_adaptive(p_var = 'sample_clonality', compartment = 'tumor', 
                       facet_var = NULL)
plot_parallel_adaptive(p_var = 'adaptive_t_cells', compartment = 'tumor', 
                       facet_var = NULL)
plot_parallel_adaptive(p_var = 'sample_clonality', compartment = 'blood',
                       facet_var = NULL)
plot_parallel_adaptive(p_var = 'efron_thisted_estimator', compartment = 'blood',
                       facet_var = NULL)
plot_parallel_adaptive(p_var = 'adaptive_t_cells', compartment = 'blood',
                       facet_var = NULL)
```

```{r, fig.width = 7, fig.height = 3, warning=FALSE, echo=FALSE}
plot_parallel_adaptive(p_var = 'efron_thisted_estimator', compartment = 'tumor',
                       facet_var = 'arm')
plot_parallel_adaptive(p_var = 'sample_clonality', compartment = 'tumor', 
                       facet_var = 'arm')
plot_parallel_adaptive(p_var = 'adaptive_t_cells', compartment = 'tumor', 
                       facet_var = 'arm')
plot_parallel_adaptive(p_var = 'efron_thisted_estimator', compartment = 'blood',
                       facet_var = 'arm')
plot_parallel_adaptive(p_var = 'sample_clonality', compartment = 'blood',
                       facet_var = 'arm')
plot_parallel_adaptive(p_var = 'adaptive_t_cells', compartment = 'blood',
                       facet_var = 'arm')
```

Highly interesting to me: repertoire size is correlated with response at
baseline, but not post-induction or on nivo.
On the contrary, clonality is associated with response post-induction and on
nivo, T-cell infiltration only on-nivo.

```{r, warning=FALSE, echo=FALSE, results='asis'}
source('R/plotting_adaptive.R')
res <- test_adaptive_association(timepoint = 'Baseline')
print(knitr::kable(res))
res <- test_adaptive_association(timepoint = 'Post-induction')
print(knitr::kable(res))
res <- test_adaptive_association(timepoint = 'On nivo')
print(knitr::kable(res))
```

```{r, warning=FALSE, echo=FALSE}
source('R/plotting_adaptive.R')
res <- test_adaptive_association(timepoint = '-2')
print(knitr::kable(res))
res <- test_adaptive_association(timepoint = '0')
print(knitr::kable(res))
res <- test_adaptive_association(timepoint = '6')
print(knitr::kable(res))
res <- test_adaptive_association(timepoint = '12')
print(knitr::kable(res))
```

```{r, eval = F, warning=FALSE, echo=FALSE}
source('R/plotting_nanostring.R')
cowplot::plot_grid(
  plot_parallel_adaptive(p_var = 'efron_thisted_estimator') + remove_x +
    remove_legend + scale_y_continuous(trans = 'log10',
                                       name = 'Repertoire size'),
  plot_parallel_adaptive(p_var = 'sample_clonality') + remove_strip +
    theme(legend.position = 'top'),
  s_plot + remove_strip, ncol = 1, align = 'hv', rel_heights = c(.4, .4, .6))
```

```{r, warning=FALSE, echo=FALSE}
plot_all_comps(f = compare_adaptive_summary_stats,
               colour_var = 'clinical_response',
               x_var = 'clinical_response',
               facet_var = NULL)
```

Effect of induction arm on these measures

```{r, eval = T, warning=FALSE, echo=FALSE}
plot_all_comps(f = compare_adaptive_summary_stats,
               colour_var = 'arm',
               x_var = 'arm',
               facet_var = NULL)
```

Split out by clinical response, contrasts most pronounced in responders

```{r, warning=FALSE, echo=FALSE}
plot_all_comps(f = compare_adaptive_summary_stats,
               colour_var = 'clinical_response',
               x_var = 'clinical_response',
               facet_var = 'arm')
```


```{r, eval = F, warning=FALSE, echo=FALSE}
# devtools::load_all(file.path('~/libs', 'maartenutils'))
if (!exists('arr')) read_adaptive_seqs()
# arr[, sum(productive_frequency, na.rm = T), by = sample_name][, table(V1)]
# arr[, uniqueN(amino_acid), by = 'patient'][, summary(V1)]
```

```{r, eval = F, warning=FALSE, echo=FALSE}
## Investigate propagation of clones between timepoints
arr[patient == patient[2], .N, by = amino_acid][, table(N)]
repeated_clones <-
  arr[patient == patient[2], .N, by = amino_acid][N > 1, amino_acid]
arr[patient == patient[2] & amino_acid %in% repeated_clones][order(amino_acid)]
```


```{r, eval = F, warning=FALSE, echo=FALSE}
source('R/plotting_adaptive.R')
# options(warn=2, error=recover)
# arr[, .SD[, timepoint], by = patient]
# arr[, .N, by = .(timepoint, patient)][naturalorder(patient)]
# options(warn=0, error=NULL)
# arr[, uniqueN(timepoint), by = patient]
# arr[patient == 'pat_6', unique(timepoint)]

## Compute FCs for all patients, by TCR
# FCs[!is.na(fc1) | !is.na(fc2)]
# FCs_11[!is.na(fc2)]
# arr[amino_acid %in% FCs[eps(fc1) & eps(fc2), amino_acid]][order(amino_acid)]
```

<!--
Combine two timepoints or samples (e.g. blood vs. tumor) by computing:
  * Spearman and Pearson correlation coefficients between TCR clones sizes
  * Fraction of non-axis`*` corresponding quartile TCR clones. Non-axis is
    defined as not zero in either timepoint, corresponding quartile as having
  * 
-->

# FCs between timepoints shared between tumor and blood

```{r, eval = F, warning=FALSE, echo=FALSE}
FCs_dir <- file.path(rds_dir, 'FCs')
list.files(FCs_dir, full.names = T)
list.files(FCs_dir)
```

```{r, warning=FALSE, echo=FALSE, results = 'hide'}
plot_tp_comp_FCs(tp1 = 'Baseline', tp2 = 'Post-induction', 
                 tp3 = '-2', tp4 = '0')
plot_tp_comp_FCs(tp1 = 'Baseline', tp2 = 'On nivo', 
                 tp3 = '-2', tp4 = '6')
plot_tp_comp_FCs(tp1 = 'Baseline', tp2 = 'On nivo', 
                 tp3 = '-2', tp4 = '10')
plot_tp_comp_FCs(tp1 = 'Baseline', tp2 = 'On nivo', 
                 tp3 = '-2', tp4 = '12')
```

# Direct comparison of tumor and blood

```{r, warning=FALSE, echo=FALSE, results = 'hide'}
plot_tp_comp_direct(tp1 = 'Baseline', tp2 = '-2')
plot_tp_comp_direct(tp1 = 'Post-induction', tp2 = '0')
plot_tp_comp_direct(tp1 = 'On nivo', tp2 = '6')
plot_tp_comp_direct(tp1 = 'On nivo', tp2 = '10')
plot_tp_comp_direct(tp1 = 'On nivo', tp2 = '12')
```

# Tracing individual TCRs

```{r, warning=FALSE, echo=FALSE}
source('R/plotting_nanostring.R')
source('R/plotting_adaptive.R')

# read_adaptive_seqs(force_reload = T)

plot_TCR_chronological(p_var = 'normalized_frequency') +
  ggtitle('Normalised for T cell infiltration')
```

We should be interested in clone size relative to all (nucleated) cells, rather
than relative to the other T cells, but the latter is the default metric that
Adaptive reports (i.e. productive frequency). Productive frequency is however
problematic when comparing samples from the same patient - as we're
doing here - as the relative size of a clone depends on the sizes of the other
clones and as such expansion of a clone will automatically mean the lowering of
the relative contribution of the other clones. I corrected the relative
contribution by multiplying it with the fraction
of T-cells over all nucleated cells (spectrophotometric estimate).

```{r, warning=FALSE, echo=FALSE}
plot_TCR_chronological(patient = 'pat_11', 
                       p_var = 'productive_frequency') + 
  ggtitle('Not normalised for T cell infiltration')
plot_TCR_chronological(patient = 'pat_11',
                       p_var = 'normalized_frequency') +
  ggtitle('Normalised for T cell infiltration')
```
